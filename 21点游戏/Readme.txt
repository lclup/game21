简化的21点游戏：
有一个庄家向玩家发放有点数的扑克牌，每个玩家尽可能的将手中牌的点数接近21点，但是不能超过21点，数字牌的点数就是牌面值，A的点数是1或者11由玩家决定，JQK都为10点。
计算机是庄家，支持1-7个玩家，游戏开始的时候，庄家向所有的玩家发放两张扑克牌，玩家可以看到他们的牌以及点数总和，然而，庄家有一张牌不可见。
每个玩家如果愿意，就可以添加一张牌，如果当前玩家添加以后，总点数超过21，该玩家失败。当所有的玩家加牌完毕以后，庄家亮出隐藏的牌。如果庄家的牌小于等于16，庄家必须要牌。如果庄家超过21，则点数没有超过21的玩家胜出。否则就比较庄家的总点数和剩下玩家的点数，如果某个玩家大于庄家，玩家获胜，反之失败，如果一样，打和。
类的设计
类	基类	描述
Game	无	游戏的主题类，死循环（Client类），主应用程序线程app
Player	GenericPlayer	人类玩家
House	GenericPlayer	计算机庄家
GenericPlayer	Hand	抽象的卡牌游戏玩家，有待具体实现，我要把人类和计算机的共同属性抽象出来，（我需要将player，House的某些共同的属性以合并同类项的形式，规定起来）
Card		扑克牌：就是呈现花色和点数
Hand		玩家拿的牌
Deck	Hand	牌堆
玩家为什么会是Hand的派生类：
我们将Card作为真实的扑克牌，首先肯定有发牌的过程，我们希望真正发牌的时候，不是对card对象进行复制，我们只复制指针。
我们将玩家当作有名字的一个Hand，我们可以把玩家和计算机都看成一个有名字的卡牌堆集合，游戏的时序流程，就是把一个满堆（起始的牌堆）向各个分堆，进行发送的过程。那么我们认为玩家派生于card是很自然。
牌堆和庄家在逻辑上解耦合，牌堆可以用一个统一的分方法，向计算机和向玩家发牌。Deck类有一个发牌的成员函数，该函数是多态的，能作用于Player和House对象。
